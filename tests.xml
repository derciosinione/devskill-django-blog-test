<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="4" skipped="0" tests="8" time="1.496" timestamp="2022-01-08T02:24:47.362333" hostname="Allstack"><testcase classname="tests.test_blog.IndexPageTest" name="test_view_has_link" file="tests\test_blog.py" line="11" time="0.185"><failure message="django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.">request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.test.client.ClientHandler object at 0x000001A419509450&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
    
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
    
&gt;       resolver_match = resolver.resolve(request.path_info)

venv\lib\site-packages\django\core\handlers\base.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, path = '/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
&gt;           for pattern in self.url_patterns:

venv\lib\site-packages\django\urls\resolvers.py:527: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5ECE0&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
&gt;       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv\lib\site-packages\django\urls\resolvers.py:571: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4193457B0&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4193457B0&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A4195271B0, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x000001A419509E70&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A4193E3E40&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419344AF0&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419344AF0&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A4193C94D0, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.contrib.messages.middleware.MessageMiddleware object at 0x000001A41950A350&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A4193E0D00&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419344070&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419344070&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A41952B3C0, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.contrib.auth.middleware.AuthenticationMiddleware object at 0x000001A419509A50&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A41936A480&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419344B20&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419344B20&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A4194964A0, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.csrf.CsrfViewMiddleware object at 0x000001A419509870&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A4193E25C0&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4193464A0&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4193464A0&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A4193666B0, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.common.CommonMiddleware object at 0x000001A4195091B0&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A4193D4680&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419344040&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419344040&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A419365210, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.contrib.sessions.middleware.SessionMiddleware object at 0x000001A4195090C0&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A41936B500&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419346950&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419346950&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A419365160, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.security.SecurityMiddleware object at 0x000001A419509390&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A41949A080&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419347760&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419347760&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A419496EF0, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

self = &lt;tests.test_blog.IndexPageTest testMethod=test_view_has_link&gt;

    def setUp(self):
        self.client = Client()
&gt;       self.response = self.client.get("/")

tests\test_blog.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv\lib\site-packages\django\test\client.py:535: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:345: in get
    return self.generic('GET', path, secure=secure, **{
venv\lib\site-packages\django\test\client.py:422: in generic
    return self.request(**r)
venv\lib\site-packages\django\test\client.py:485: in request
    response = self.handler(environ)
venv\lib\site-packages\django\test\client.py:140: in __call__
    response = self.get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:75: in get_response
    response = self._middleware_chain(request)
venv\lib\site-packages\django\core\handlers\exception.py:36: in inner
    response = response_for_exception(request, exc)
venv\lib\site-packages\django\core\handlers\exception.py:90: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv\lib\site-packages\django\core\handlers\exception.py:128: in handle_uncaught_exception
    callback, param_dict = resolver.resolve_error_handler(500)
venv\lib\site-packages\django\urls\resolvers.py:584: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv\lib\site-packages\django\utils\functional.py:80: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv\lib\site-packages\django\urls\resolvers.py:564: in urlconf_module
    return import_module(self.urlconf_name)
C:\Python310\lib\importlib\__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:883: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:241: in _call_with_frames_removed
    ???
mysite\urls.py:6: in &lt;module&gt;
    url(r"^", include("blog.urls", namespace="blog")),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured</failure></testcase><testcase classname="tests.test_blog.IndexPageTest" name="test_view_works" file="tests\test_blog.py" line="8" time="0.009"><failure message="django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.">request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.test.client.ClientHandler object at 0x000001A4197F7AF0&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
    
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
    
&gt;       resolver_match = resolver.resolve(request.path_info)

venv\lib\site-packages\django\core\handlers\base.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, path = '/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
&gt;           for pattern in self.url_patterns:

venv\lib\site-packages\django\urls\resolvers.py:527: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5ECE0&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
&gt;       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv\lib\site-packages\django\urls\resolvers.py:571: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F6B30&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F6B30&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A4197C3680, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x000001A4197F73A0&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A41981C480&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F69B0&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F69B0&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A4197C3260, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.contrib.messages.middleware.MessageMiddleware object at 0x000001A4197F75B0&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A4197CD000&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F6B60&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F6B60&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A4197C3940, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.contrib.auth.middleware.AuthenticationMiddleware object at 0x000001A4197F72E0&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A4197CF380&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F6DA0&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F6DA0&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A4197C3AA0, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.csrf.CsrfViewMiddleware object at 0x000001A4197F7280&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A4197CFE40&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F69E0&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F69E0&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A41953AEF0, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.common.CommonMiddleware object at 0x000001A4197F76D0&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A4197CD7C0&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F6950&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F6950&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A4197C2FA0, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.contrib.sessions.middleware.SessionMiddleware object at 0x000001A4197F7190&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A4197CF0C0&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F5E40&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F5E40&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A4197C3B50, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.security.SecurityMiddleware object at 0x000001A4197F7790&gt;, request = &lt;WSGIRequest: GET '/'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A4197CCD00&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F5DB0&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A4197F5DB0&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A4197C1F20, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

self = &lt;tests.test_blog.IndexPageTest testMethod=test_view_works&gt;

    def setUp(self):
        self.client = Client()
&gt;       self.response = self.client.get("/")

tests\test_blog.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv\lib\site-packages\django\test\client.py:535: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:345: in get
    return self.generic('GET', path, secure=secure, **{
venv\lib\site-packages\django\test\client.py:422: in generic
    return self.request(**r)
venv\lib\site-packages\django\test\client.py:485: in request
    response = self.handler(environ)
venv\lib\site-packages\django\test\client.py:140: in __call__
    response = self.get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:75: in get_response
    response = self._middleware_chain(request)
venv\lib\site-packages\django\core\handlers\exception.py:36: in inner
    response = response_for_exception(request, exc)
venv\lib\site-packages\django\core\handlers\exception.py:90: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv\lib\site-packages\django\core\handlers\exception.py:128: in handle_uncaught_exception
    callback, param_dict = resolver.resolve_error_handler(500)
venv\lib\site-packages\django\urls\resolvers.py:584: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv\lib\site-packages\django\utils\functional.py:80: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv\lib\site-packages\django\urls\resolvers.py:564: in urlconf_module
    return import_module(self.urlconf_name)
C:\Python310\lib\importlib\__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:883: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:241: in _call_with_frames_removed
    ???
mysite\urls.py:6: in &lt;module&gt;
    url(r"^", include("blog.urls", namespace="blog")),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured</failure></testcase><testcase classname="tests.test_blog.AddPostPageTest" name="test_adding_works" file="tests\test_blog.py" line="25" time="0.007"><failure message="django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.">request = &lt;WSGIRequest: POST '/add_post'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.common.CommonMiddleware object at 0x000001A41966A680&gt;, request = &lt;WSGIRequest: POST '/add_post'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
&gt;           response = self.process_request(request)

venv\lib\site-packages\django\utils\deprecation.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.common.CommonMiddleware object at 0x000001A41966A680&gt;, request = &lt;WSGIRequest: POST '/add_post'&gt;

    def process_request(self, request):
        """
        Check for denied User-Agents and rewrite the URL based on
        settings.APPEND_SLASH and settings.PREPEND_WWW
        """
    
        # Check for denied User-Agents
        if 'HTTP_USER_AGENT' in request.META:
            for user_agent_regex in settings.DISALLOWED_USER_AGENTS:
                if user_agent_regex.search(request.META['HTTP_USER_AGENT']):
                    raise PermissionDenied('Forbidden user agent')
    
        # Check for a redirect based on settings.PREPEND_WWW
        host = request.get_host()
        must_prepend = settings.PREPEND_WWW and host and not host.startswith('www.')
        redirect_url = ('%s://www.%s' % (request.scheme, host)) if must_prepend else ''
    
        # Check if a slash should be appended
&gt;       if self.should_redirect_with_slash(request):

venv\lib\site-packages\django\middleware\common.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.common.CommonMiddleware object at 0x000001A41966A680&gt;, request = &lt;WSGIRequest: POST '/add_post'&gt;

    def should_redirect_with_slash(self, request):
        """
        Return True if settings.APPEND_SLASH is True and appending a slash to
        the request path turns an invalid path into a valid one.
        """
        if settings.APPEND_SLASH and not request.path_info.endswith('/'):
            urlconf = getattr(request, 'urlconf', None)
            return (
&gt;               not is_valid_path(request.path_info, urlconf) and
                is_valid_path('%s/' % request.path_info, urlconf)
            )

venv\lib\site-packages\django\middleware\common.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = '/add_post', urlconf = None

    def is_valid_path(path, urlconf=None):
        """
        Return True if the given path resolves against the default URL resolver,
        False otherwise. This is a convenience method to make working with "is
        this a match?" cases easier, avoiding try...except blocks.
        """
        try:
&gt;           resolve(path, urlconf)

venv\lib\site-packages\django\urls\base.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = '/add_post', urlconf = 'mysite.urls'

    def resolve(path, urlconf=None):
        if urlconf is None:
            urlconf = get_urlconf()
&gt;       return get_resolver(urlconf).resolve(path)

venv\lib\site-packages\django\urls\base.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, path = '/add_post'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
&gt;           for pattern in self.url_patterns:

venv\lib\site-packages\django\urls\resolvers.py:527: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5ECE0&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
&gt;       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv\lib\site-packages\django\urls\resolvers.py:571: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A41966A170&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A41966A170&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A419469B00, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: POST '/add_post'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.contrib.sessions.middleware.SessionMiddleware object at 0x000001A41966A500&gt;, request = &lt;WSGIRequest: POST '/add_post'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: POST '/add_post'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: POST '/add_post'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: POST '/add_post'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A419695CC0&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419669DB0&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419669DB0&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A41946BB50, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: POST '/add_post'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.security.SecurityMiddleware object at 0x000001A41966A5F0&gt;, request = &lt;WSGIRequest: POST '/add_post'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: POST '/add_post'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: POST '/add_post'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: POST '/add_post'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A419778080&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A41966A050&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A41966A050&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A41937F940, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

self = &lt;tests.test_blog.AddPostPageTest testMethod=test_adding_works&gt;

    def test_adding_works(self):
&gt;       r = self.client.post(
            "/add_post",
            {"body": "some text", "title": "some title", "submit": "Submit"},
        )

tests\test_blog.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv\lib\site-packages\django\test\client.py:543: in post
    response = super().post(path, data=data, content_type=content_type, secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:356: in post
    return self.generic('POST', path, post_data, content_type,
venv\lib\site-packages\django\test\client.py:422: in generic
    return self.request(**r)
venv\lib\site-packages\django\test\client.py:485: in request
    response = self.handler(environ)
venv\lib\site-packages\django\test\client.py:140: in __call__
    response = self.get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:75: in get_response
    response = self._middleware_chain(request)
venv\lib\site-packages\django\core\handlers\exception.py:36: in inner
    response = response_for_exception(request, exc)
venv\lib\site-packages\django\core\handlers\exception.py:90: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv\lib\site-packages\django\core\handlers\exception.py:128: in handle_uncaught_exception
    callback, param_dict = resolver.resolve_error_handler(500)
venv\lib\site-packages\django\urls\resolvers.py:584: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv\lib\site-packages\django\utils\functional.py:80: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv\lib\site-packages\django\urls\resolvers.py:564: in urlconf_module
    return import_module(self.urlconf_name)
C:\Python310\lib\importlib\__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:883: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:241: in _call_with_frames_removed
    ???
mysite\urls.py:6: in &lt;module&gt;
    url(r"^", include("blog.urls", namespace="blog")),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured</failure></testcase><testcase classname="tests.test_blog.AddPostPageTest" name="test_view_works" file="tests\test_blog.py" line="19" time="0.006"><failure message="django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.">request = &lt;WSGIRequest: GET '/add_post'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.common.CommonMiddleware object at 0x000001A4197025F0&gt;, request = &lt;WSGIRequest: GET '/add_post'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
&gt;           response = self.process_request(request)

venv\lib\site-packages\django\utils\deprecation.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.common.CommonMiddleware object at 0x000001A4197025F0&gt;, request = &lt;WSGIRequest: GET '/add_post'&gt;

    def process_request(self, request):
        """
        Check for denied User-Agents and rewrite the URL based on
        settings.APPEND_SLASH and settings.PREPEND_WWW
        """
    
        # Check for denied User-Agents
        if 'HTTP_USER_AGENT' in request.META:
            for user_agent_regex in settings.DISALLOWED_USER_AGENTS:
                if user_agent_regex.search(request.META['HTTP_USER_AGENT']):
                    raise PermissionDenied('Forbidden user agent')
    
        # Check for a redirect based on settings.PREPEND_WWW
        host = request.get_host()
        must_prepend = settings.PREPEND_WWW and host and not host.startswith('www.')
        redirect_url = ('%s://www.%s' % (request.scheme, host)) if must_prepend else ''
    
        # Check if a slash should be appended
&gt;       if self.should_redirect_with_slash(request):

venv\lib\site-packages\django\middleware\common.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.common.CommonMiddleware object at 0x000001A4197025F0&gt;, request = &lt;WSGIRequest: GET '/add_post'&gt;

    def should_redirect_with_slash(self, request):
        """
        Return True if settings.APPEND_SLASH is True and appending a slash to
        the request path turns an invalid path into a valid one.
        """
        if settings.APPEND_SLASH and not request.path_info.endswith('/'):
            urlconf = getattr(request, 'urlconf', None)
            return (
&gt;               not is_valid_path(request.path_info, urlconf) and
                is_valid_path('%s/' % request.path_info, urlconf)
            )

venv\lib\site-packages\django\middleware\common.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = '/add_post', urlconf = None

    def is_valid_path(path, urlconf=None):
        """
        Return True if the given path resolves against the default URL resolver,
        False otherwise. This is a convenience method to make working with "is
        this a match?" cases easier, avoiding try...except blocks.
        """
        try:
&gt;           resolve(path, urlconf)

venv\lib\site-packages\django\urls\base.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = '/add_post', urlconf = 'mysite.urls'

    def resolve(path, urlconf=None):
        if urlconf is None:
            urlconf = get_urlconf()
&gt;       return get_resolver(urlconf).resolve(path)

venv\lib\site-packages\django\urls\base.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, path = '/add_post'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
&gt;           for pattern in self.url_patterns:

venv\lib\site-packages\django\urls\resolvers.py:527: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5ECE0&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
&gt;       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv\lib\site-packages\django\urls\resolvers.py:571: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419701FF0&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419701FF0&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A41944B9F0, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/add_post'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.contrib.sessions.middleware.SessionMiddleware object at 0x000001A419702560&gt;, request = &lt;WSGIRequest: GET '/add_post'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/add_post'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/add_post'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/add_post'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A4197328C0&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419701F30&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419701F30&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A4194685B0, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

request = &lt;WSGIRequest: GET '/add_post'&gt;

    @wraps(get_response)
    def inner(request):
        try:
&gt;           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.middleware.security.SecurityMiddleware object at 0x000001A419702470&gt;, request = &lt;WSGIRequest: GET '/add_post'&gt;

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
&gt;       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/add_post'&gt;

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
&gt;           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/add_post'&gt;
exc = ImproperlyConfigured('Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.')

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
&gt;           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = &lt;WSGIRequest: GET '/add_post'&gt;, resolver = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;
exc_info = (&lt;class 'django.core.exceptions.ImproperlyConfigured'&gt;, ImproperlyConfigured('Specifying a namespace in include() with...e, or pass a 2-tuple containing the list of patterns and app_name instead.'), &lt;traceback object at 0x000001A419733C00&gt;)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
&gt;       callback, param_dict = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, view_type = 500

    def resolve_error_handler(self, view_type):
&gt;       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.utils.functional.cached_property object at 0x000001A418C5EE60&gt;, instance = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;, cls = &lt;class 'django.urls.resolvers.URLResolver'&gt;

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
&gt;       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;URLResolver 'mysite.urls' (None:None) '^/'&gt;

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
&gt;           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python310\lib\importlib\__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', package = None, level = 0

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'mysite.urls', import_ = &lt;function _gcd_import at 0x000001A414B93490&gt;

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='mysite.urls', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419701C60&gt;, origin='C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py')

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:688: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001A419701C60&gt;
module = &lt;module 'mysite.urls' from 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py'&gt;

&gt;   ???

&lt;frozen importlib._bootstrap_external&gt;:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = &lt;built-in function exec&gt;
args = (&lt;code object &lt;module&gt; at 0x000001A4194690B0, file "C:\Users\pc\Documents\Projects\Aubay\e61f3b79-14fc-4ee1-bdcc-c6ba6..., '__file__': 'C:\\Users\\pc\\Documents\\Projects\\Aubay\\e61f3b79-14fc-4ee1-bdcc-c6ba6e7485c9\\mysite\\urls.py', ...})
kwds = {}

&gt;   ???

&lt;frozen importlib._bootstrap&gt;:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf.urls import url, include
    from django.contrib import admin
    
    urlpatterns = [
        url(r"^admin/", admin.site.urls),
&gt;       url(r"^", include("blog.urls", namespace="blog")),
    ]

mysite\urls.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured

During handling of the above exception, another exception occurred:

self = &lt;tests.test_blog.AddPostPageTest testMethod=test_view_works&gt;

    def test_view_works(self):
&gt;       r = self.client.get("/add_post")

tests\test_blog.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv\lib\site-packages\django\test\client.py:535: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:345: in get
    return self.generic('GET', path, secure=secure, **{
venv\lib\site-packages\django\test\client.py:422: in generic
    return self.request(**r)
venv\lib\site-packages\django\test\client.py:485: in request
    response = self.handler(environ)
venv\lib\site-packages\django\test\client.py:140: in __call__
    response = self.get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:75: in get_response
    response = self._middleware_chain(request)
venv\lib\site-packages\django\core\handlers\exception.py:36: in inner
    response = response_for_exception(request, exc)
venv\lib\site-packages\django\core\handlers\exception.py:90: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv\lib\site-packages\django\core\handlers\exception.py:128: in handle_uncaught_exception
    callback, param_dict = resolver.resolve_error_handler(500)
venv\lib\site-packages\django\urls\resolvers.py:584: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv\lib\site-packages\django\utils\functional.py:80: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv\lib\site-packages\django\urls\resolvers.py:564: in urlconf_module
    return import_module(self.urlconf_name)
C:\Python310\lib\importlib\__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:883: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:241: in _call_with_frames_removed
    ???
mysite\urls.py:6: in &lt;module&gt;
    url(r"^", include("blog.urls", namespace="blog")),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'blog.urls', namespace = 'blog'

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
            urlconf_module = import_module(urlconf_module)
        patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
        app_name = getattr(urlconf_module, 'app_name', app_name)
        if namespace and not app_name:
&gt;           raise ImproperlyConfigured(
                'Specifying a namespace in include() without providing an app_name '
                'is not supported. Set the app_name attribute in the included '
                'module, or pass a 2-tuple containing the list of patterns and '
                'app_name instead.',
            )
E           django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

venv\lib\site-packages\django\urls\conf.py:38: ImproperlyConfigured</failure></testcase><testcase classname="tests.test_structure_views.StructureTestSuite" name="test_function_exists_add_post" file="tests\test_structure_views.py" line="11" time="0.001" /><testcase classname="tests.test_structure_views.StructureTestSuite" name="test_function_exists_index" file="tests\test_structure_views.py" line="54" time="0.001" /><testcase classname="tests.test_structure_views.StructureTestSuite" name="test_function_signature_match_add_post" file="tests\test_structure_views.py" line="21" time="0.001" /><testcase classname="tests.test_structure_views.StructureTestSuite" name="test_function_signature_match_index" file="tests\test_structure_views.py" line="64" time="0.003" /></testsuite></testsuites>